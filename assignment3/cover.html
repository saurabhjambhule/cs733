
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/saurabhjambhule/cs733/assignment3/raft_dt.go (0.0%)</option>
				
				<option value="file1">github.com/saurabhjambhule/cs733/assignment3/raft_node.go (89.3%)</option>
				
				<option value="file2">github.com/saurabhjambhule/cs733/assignment3/raft_sm.go (74.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package main

import (
        "time"

        "github.com/cs733-iitb/cluster"
        "github.com/cs733-iitb/log"
)

//------------------------||RAFT NODE DS||------------------------//
//Constant for timeout.
const (
        FTIME = 1500 //seconds
        CTIME = 1500 //seconds(re-election)
        LTIME = 150  //milliseconds(haertbeat)
        RANGE = 1500 //timeout upperlimit in seconds for candidate and follower
)

type CommitInfo struct {
        Data  []byte
        Index int32
        Err   error
}

//Contains raft node related data .
type Config struct {
        Id               int    //this node's id. One of the cluster's entries should match
        LogDir           string //Log file directory for this node
        ElectionTimeout  int
        HeartbeatTimeout int
        DoTO             *time.Timer //timeout the state after DoTO
        lg               *log.Log
}

//Contains all raft node's data of entire cluster.
type MyConfig struct {
        Details []Config
}

//Contains server related data.
type RaftMachine struct {
        Node cluster.Server
        SM   *State_Machine
        Conf *Config
}

//Contains data of entire cluster.
//and the channel through which client communicate to raft.
type Raft struct {
        Cluster    []*RaftMachine
        CommitInfo chan interface{}
}

type incomming interface {
}

//----------------------||STATE MACHINE DS||----------------------//
const (
        FOLL  = "follower"
        CAND  = "Candidate"
        LEAD  = "leader"
        PEERS = 5
        MAX   = 3
        FTO   = 0
        CTO   = 1
        LTO   = 2
)

//Contains persistent state of all servers.
type Persi_State struct {
        id        int32
        currTerm  int32
        votedFor  int32
        VoteGrant [2]int32
        LoggInd   int32
        status    string
        LeaderId  int32
}

//Contains volatile state of servers.
type Volat_State struct {
        CommitIndex int32
        LastApplied int32
}

//Contains volatile state of the leader.
type Volat_LState struct {
        NextIndex  [PEERS]int32
        MatchIndex [PEERS]int32
}

//Stores Logg entries
type MyLogg struct {
        Term int32
        Logg string
}

type Logg struct {
        Logg []MyLogg
}

//Stores PEERS
//var Peer map[int32]int32

//Contains all the state with respect to given machine.
type State_Machine struct {
        Persi_State
        Volat_State
        Volat_LState
        Logg Logg
        CommMedium
}

type CommMedium struct {
        //Channel declaration for listening to incomming requests.
        clientCh  chan interface{}
        netCh     chan interface{}
        timeoutCh chan interface{}
        //Channel for providing respond to given request.
        actionCh chan interface{}
        CommitCh chan interface{}
}

//AppendEntriesRequest: Invoked by leader to replicate Logg entries and also used as heartbeat.
type AppEntrReq struct {
        Term        int32
        LeaderId    int32
        PreLoggInd  int32
        PreLoggTerm int32
        LeaderCom   int32
        Logg        Logg
}

//AppendEntriesResponse: Invoked by servers on AppendEntriesRequest.
type AppEntrResp struct {
        Peer int32
        Term int32
        Succ bool
}

//VoteRequest: Invoked by CandIdates to gather votes.
type VoteReq struct {
        Term        int32
        CandId      int32
        PreLoggInd  int32
        PreLoggTerm int32
}

//VoteResponse: Invoked by servers on VoteRequest.
type VoteResp struct {
        Term      int32
        VoteGrant bool
}

//This is a request from the layer above to append the data to the replicated Logg.
type Append struct {
        Data []byte
}

//A timeout Event.`
type Timeout struct {
}

//Send this Event to a remote node.
type Send struct {
        PeerId int32
        Event  interface{}
}

//Invoked by the leader on Append request. Provides (Index + data) or report an error (data + err) to the layer above.
type Commit struct {
        Index int32
        Data  []byte
        Err   []byte
}

//Send a Timeout after t milliseconds.
type Alarm struct {
        T int
}

//This is an indication to the node to store the Logg at the given Index.
type LoggStore struct {
        //Index int32
        Data []MyLogg
}

//This is an indication to the node to store the state in the memory.
type StateStore struct {
        Data []byte
}

//Returns respond to given request.
func (appReq AppEntrReq) alarm(sm *State_Machine)    <span class="cov0" title="0">{}</span>
func (appResp AppEntrResp) alarm(sm *State_Machine)  <span class="cov0" title="0">{}</span>
func (votReq VoteReq) alarm(sm *State_Machine)       <span class="cov0" title="0">{}</span>
func (votResp VoteResp) alarm(sm *State_Machine)     <span class="cov0" title="0">{}</span>
func (app Append) alarm(sm *State_Machine)           <span class="cov0" title="0">{}</span>
func (appReq AppEntrReq) commit(sm *State_Machine)   <span class="cov0" title="0">{}</span>
func (appResp AppEntrResp) commit(sm *State_Machine) <span class="cov0" title="0">{}</span>
func (votReq VoteReq) commit(sm *State_Machine)      <span class="cov0" title="0">{}</span>
func (votResp VoteResp) commit(sm *State_Machine)    <span class="cov0" title="0">{}</span>
func (to Timeout) commit(sm *State_Machine)          <span class="cov0" title="0">{}</span>
func (app Append) send(sm *State_Machine)            <span class="cov0" title="0">{}</span>
func (to Timeout) send(sm *State_Machine)            <span class="cov0" title="0">{}</span>
func (to Timeout) alarm(sm1 *State_Machine)          <span class="cov0" title="0">{}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "encoding/gob"
        "encoding/json"
        "fmt"
        "math/rand"
        "os"
        "time"

        "github.com/cs733-iitb/cluster"
        "github.com/cs733-iitb/cluster/mock"
        "github.com/cs733-iitb/log"
)

//Current Id of leader. -1 if unknown
func (myRaft Raft) LeaderId() int <span class="cov0" title="0">{
        for i := 0; i &lt; PEERS; i++ </span><span class="cov0" title="0">{
                if myRaft.Cluster[i].SM.status == LEAD </span><span class="cov0" title="0">{
                        return i + 1
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

//Blocks until leader electected and return leader id.
func (myRaft Raft) GetLeader() int <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                fmt.Print("")
                for i := 0; i &lt; PEERS; i++ </span><span class="cov8" title="1">{
                        if myRaft.Cluster[i].SM.status == LEAD </span><span class="cov8" title="1">{
                                return i
                        }</span>
                }
        }
        <span class="cov0" title="0">return -1</span>
}

//Signal to shut down all goroutines, stop sockets, flush log and close it, cancel timers.
func Shutdown(server cluster.Server) <span class="cov0" title="0">{
        server.Close()
}</span>

//Client's message to Raft node
func (server RaftMachine) Append(cmdReq []byte) <span class="cov8" title="1">{
        reqApp := Append{Data: cmdReq}
        server.SM.CommMedium.clientCh &lt;- reqApp
}</span>

//Process incoming events from StateMachine.
func processEvents(server cluster.Server, sm *State_Machine, myConf *Config) <span class="cov8" title="1">{
        var incm incomming
        for </span><span class="cov8" title="1">{
                select </span>{
                <span class="cov8" title="1">case incm := &lt;-sm.CommMedium.actionCh:
                        switch incm.(type) </span>{
                        <span class="cov8" title="1">case Send:
                                msg := incm.(Send)
                                processOutbox(server, sm, msg)</span>

                        <span class="cov8" title="1">case Alarm:
                                //Reset the timer of timeout.
                                myConf.DoTO.Stop()
                                al := incm.(Alarm)
                                if al.T == LTO </span><span class="cov8" title="1">{
                                        myConf.DoTO = time.AfterFunc(time.Duration(LTIME)*time.Millisecond, func() </span><span class="cov8" title="1">{
                                                myConf.DoTO.Stop()
                                                sm.CommMedium.timeoutCh &lt;- nil
                                        }</span>)
                                }
                                <span class="cov8" title="1">if al.T == CTO </span><span class="cov8" title="1">{
                                        myConf.ElectionTimeout = (CTIME + rand.Intn(RANGE))
                                        myConf.DoTO = time.AfterFunc(time.Duration(myConf.ElectionTimeout)*time.Millisecond, func() </span><span class="cov8" title="1">{
                                                myConf.DoTO.Stop()
                                                sm.CommMedium.timeoutCh &lt;- nil
                                        }</span>)
                                }
                                <span class="cov8" title="1">if al.T == FTO </span><span class="cov8" title="1">{
                                        myConf.ElectionTimeout = (FTIME + rand.Intn(RANGE))
                                        myConf.DoTO = time.AfterFunc(time.Duration(myConf.ElectionTimeout)*time.Millisecond, func() </span><span class="cov8" title="1">{
                                                myConf.DoTO.Stop()
                                                sm.CommMedium.timeoutCh &lt;- nil
                                        }</span>)
                                }

                        <span class="cov0" title="0">case Commit:</span>

                        <span class="cov8" title="1">case LoggStore:
                                //for adding log into db.
                                msg := incm.(LoggStore)
                                storeDate(msg.Data, myConf)</span>

                        <span class="cov0" title="0">case StateStore:</span>
                        }
                }
        }
        <span class="cov0" title="0">fmt.Println("Bye", incm)</span>
}

//Process to listen incomming packets from other Servers.
func processInbox(server cluster.Server, sm *State_Machine) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                env := &lt;-server.Inbox()
                switch env.Msg.(type) </span>{
                <span class="cov8" title="1">case VoteReq:
                        sm.CommMedium.netCh &lt;- env.Msg</span>
                <span class="cov8" title="1">case VoteResp:
                        sm.CommMedium.netCh &lt;- env.Msg</span>
                <span class="cov8" title="1">case AppEntrReq:
                        sm.CommMedium.netCh &lt;- env.Msg</span>
                <span class="cov8" title="1">case AppEntrResp:
                        sm.CommMedium.netCh &lt;- env.Msg</span>
                }
        }
}

//Process to send packets to other Servers.
func processOutbox(server cluster.Server, sm *State_Machine, msg Send) <span class="cov8" title="1">{
        //broadcaste messagess.
        if msg.PeerId == 0 </span><span class="cov8" title="1">{
                switch msg.Event.(type) </span>{
                <span class="cov8" title="1">case AppEntrReq:
                        AppReq := msg.Event.(AppEntrReq)
                        server.Outbox() &lt;- &amp;cluster.Envelope{Pid: cluster.BROADCAST, MsgId: 11, Msg: AppReq}</span>
                <span class="cov8" title="1">case VoteReq:
                        VotReq := msg.Event.(VoteReq)
                        server.Outbox() &lt;- &amp;cluster.Envelope{Pid: cluster.BROADCAST, MsgId: 1, Msg: VotReq}</span>
                }
        }<span class="cov8" title="1"> else {
                //send to particular node.
                switch msg.Event.(type) </span>{
                <span class="cov8" title="1">case AppEntrReq:
                        AppReq := msg.Event.(AppEntrReq)
                        server.Outbox() &lt;- &amp;cluster.Envelope{Pid: int(msg.PeerId), MsgId: 11, Msg: AppReq}</span>
                <span class="cov8" title="1">case AppEntrResp:
                        AppResp := msg.Event.(AppEntrResp)
                        AppResp.Peer = int32(server.Pid())
                        server.Outbox() &lt;- &amp;cluster.Envelope{Pid: int(msg.PeerId), MsgId: 22, Msg: AppResp}</span>
                <span class="cov8" title="1">case VoteResp:
                        VotResp := msg.Event.(VoteResp)
                        server.Outbox() &lt;- &amp;cluster.Envelope{Pid: int(msg.PeerId), MsgId: 2, Msg: VotResp}</span>
                }
        }
}

//Storing log entries in database.
func storeDate(data []MyLogg, myConf *Config) <span class="cov8" title="1">{
        for i := 0; i &lt; len(data); i++ </span><span class="cov8" title="1">{
                err := myConf.lg.Append(data[i])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("error:", err)
                }</span>
        }
}

//Configuration of Log and Node.
func logConfig(myid int, myConf *Config) <span class="cov8" title="1">{
        var conf MyConfig
        file, _ := os.Open("log_config.json")
        decoder := json.NewDecoder(file)
        err := decoder.Decode(&amp;conf)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error:", err)
        }</span>

        <span class="cov8" title="1">foundMyId := false
        //initializing config structure from jason file.
        for _, srv := range conf.Details </span><span class="cov8" title="1">{
                if srv.Id == myid </span><span class="cov8" title="1">{
                        foundMyId = true
                        myConf.Id = myid
                        myConf.LogDir = srv.LogDir
                        myConf.ElectionTimeout = srv.ElectionTimeout
                        myConf.HeartbeatTimeout = srv.HeartbeatTimeout
                }</span>
        }
        <span class="cov8" title="1">if !foundMyId </span><span class="cov0" title="0">{
                fmt.Println("Expected this server's id (\"%d\") to be present in the configuration", myid)
        }</span>
}

func (myRaft Raft) startNode(myConf *Config, server cluster.Server, sm *State_Machine) <span class="cov8" title="1">{
        //Start backaground process to listen incomming packets from other servers.
        go processInbox(server, sm)
        //Start StateMachine in follower state.
        go sm.FollSys()
        //Raft node Processing.
        processEvents(server, sm, myConf)
}</span>

func (myRaft Raft) makeMockRafts() (Raft, *mock.MockCluster) <span class="cov8" title="1">{
        //create mock cluster.
        clconfig := cluster.Config{Peers: nil}
        cl, err := mock.NewCluster(clconfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">myRaft.CommitInfo = make(chan interface{})
        for id := 1; id &lt;= PEERS; id++ </span><span class="cov8" title="1">{
                //Ojects to store statemachine, config and server node.
                myNode := new(RaftMachine)
                sm := new(State_Machine)
                myConf := new(Config)

                //initialize config and server object.
                server := initMockNode(id, myConf, sm, cl)
                sm.id = int32(id)
                myNode.Node = server
                myNode.SM = sm
                myNode.Conf = myConf
                //append object related to node into raft array.
                myRaft.Cluster = append(myRaft.Cluster, myNode)
                //start all the processing threads.
                go myRaft.startNode(myRaft.Cluster[id-1].Conf, myRaft.Cluster[id-1].Node, myRaft.Cluster[id-1].SM)
        }</span>
        <span class="cov8" title="1">return myRaft, cl</span>
}

func initMockNode(id int, myConf *Config, sm *State_Machine, cl *mock.MockCluster) cluster.Server <span class="cov8" title="1">{
        //Register a struct name by giving it a dummy object of that name.
        gob.Register(AppEntrReq{})
        gob.Register(AppEntrResp{})
        gob.Register(VoteReq{})
        gob.Register(VoteResp{})
        gob.Register(StateStore{})
        gob.Register(LoggStore{})
        gob.Register(CommitInfo{})
        gob.Register(MyLogg{})

        //Channel initialization.
        sm.CommMedium.clientCh = make(chan interface{})
        sm.CommMedium.netCh = make(chan interface{})
        sm.CommMedium.timeoutCh = make(chan interface{})
        sm.CommMedium.actionCh = make(chan interface{})
        sm.CommMedium.CommitCh = make(chan interface{})

        //Seed randon number generator.
        rand.Seed(time.Now().UTC().UnixNano() * int64(id))

        // Give each raftNode its own "Server" from the cluster.
        server, err := cl.AddServer(id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        //Initialize the Log and Node configuration.
        <span class="cov8" title="1">logConfig(id, myConf)
        myConf.lg, err = log.Open(myConf.LogDir)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        //Initialize the timer object for timeuts.
        <span class="cov8" title="1">myConf.DoTO = time.AfterFunc(10, func() </span><span class="cov8" title="1">{}</span>)
        <span class="cov8" title="1">return server</span>
}

/*
/**************---------------------NORMAL SERVER CODE USING PORTS WORKING---------------------**************

func (myRaft Raft) makeRafts() Raft {
        myRaft.CommitInfo = make(chan interface{})
        for id := 1; id &lt;= PEERS; id++ {
                //fmt.Println(id)
                myNode := new(RaftMachine)
                sm := new(State_Machine)
                myConf := new(Config)
                server := initializeNode(id, myConf, sm)
                sm.id = int32(id)
                myNode.Node = server
                myNode.SM = sm
                myNode.Conf = myConf
                myRaft.Cluster = append(myRaft.Cluster, myNode)
                go myRaft.startNode(myRaft.Cluster[id-1].Conf, myRaft.Cluster[id-1].Node, myRaft.Cluster[id-1].SM)
        }
        return myRaft
}

//Craetes node, statemachine &amp; Initializes the node.
func initializeNode(id int, myConf *Config, sm *State_Machine) cluster.Server {
        //Register a struct name by giving it a dummy object of that name.
        gob.Register(AppEntrReq{})
        gob.Register(AppEntrResp{})
        gob.Register(VoteReq{})
        gob.Register(VoteResp{})
        gob.Register(StateStore{})
        gob.Register(LoggStore{})
        gob.Register(CommitInfo{})
        gob.Register(MyLogg{})

        //Channel initialization.
        sm.CommMedium.clientCh = make(chan interface{})
        sm.CommMedium.netCh = make(chan interface{})
        sm.CommMedium.timeoutCh = make(chan interface{})
        sm.CommMedium.actionCh = make(chan interface{})
        sm.CommMedium.CommitCh = make(chan interface{})

        rand.Seed(time.Now().UTC().UnixNano() * int64(id))
        //Set up details about cluster nodes form json file.
        server, err := cluster.New(id, "cluster_config.json")
        if err != nil {
                panic(err)
        }
        //Initialize the Log and Node configuration.
        logConfig(id, myConf)
        myConf.lg, err = log.Open(myConf.LogDir)
        if err != nil {
                panic(err)
        }
        //fmt.Printf("---: %T \n", myConf.lg)

        myConf.DoTO = time.AfterFunc(10, func() {})

        return server
}

func main() {
        myRaft := new(Raft)
        myNode := new(RaftMachine)
        sm := new(State_Machine)
        myConf := new(Config)
        flag.Parse()
        //Get Server id from command line.
        myId, _ := strconv.Atoi(flag.Args()[0])
        //Start Node.
        server := initializeNode(myId, myConf, sm)
        sm.id = int32(myId)
        myNode.Node = server
        myNode.SM = sm
        myNode.Conf = myConf
        myRaft.Cluster = append(myRaft.Cluster, myNode)
        myRaft.startNode(myRaft.Cluster[0].Conf, myRaft.Cluster[0].Node, myRaft.Cluster[0].SM)
}

***************------------------------------------------------------------------------------***************/
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "math"
        "reflect"
)

//This deals with the incomming rquest and invokes repective response Event.
type Message interface {
        send(sm *State_Machine)
        commit(sm *State_Machine)
        alarm(sm *State_Machine)
}

//Function for state to become follower.
func (sm *State_Machine) FollSys() <span class="cov8" title="1">{
        if sm.status == CAND </span><span class="cov8" title="1">{
                sm.votedFor = 1 //Reinitialize VoteFor
        }</span><span class="cov8" title="1"> else {
                sm.votedFor = 0 //Reinitialize VoteFor
        }</span>
        <span class="cov8" title="1">sm.status = FOLL //Change state status to Follower
        sm.votedFor = 0  //Reinitialize VoteFor
        sm.LeaderId = 0
        sm.VoteGrant[0] = 0 //This is positive VoteGrant counter initialized to 1 i.e. self vote
        sm.VoteGrant[1] = 0 //This is negative VoteGrant counter initialized to 0
        //fmt.Println("&gt;&gt;&gt;", sm)
        resp := Alarm{T: FTO} //200
        sm.CommMedium.actionCh &lt;- resp
        sm.EventProcess()</span>
}

//Function for state to become CandIdate.
func (sm *State_Machine) candSys() <span class="cov8" title="1">{
        sm.status = CAND    //Change state status to CandIdate
        sm.currTerm += 1    //Increament the Term
        sm.votedFor = 1     //Vote for self
        sm.VoteGrant[0] = 1 //This is positive VoteGrant counter initialized to 1 i.e. self vote
        sm.VoteGrant[1] = 0 //This is negative VoteGrant counter initialized to 0
        sm.LeaderId = 0
        //fmt.Println("&gt;&gt;&gt;", sm)
        resp := Alarm{T: CTO} //150
        sm.CommMedium.actionCh &lt;- resp
        //Sending vote request null information of previous entry as CandIdate had just joined the cluster.
        if len(sm.Logg.Logg) == 0 </span><span class="cov8" title="1">{
                respp := Send{PeerId: 0, Event: VoteReq{Term: sm.currTerm, CandId: sm.id, PreLoggInd: 0, PreLoggTerm: 0}}
                sm.CommMedium.actionCh &lt;- respp
        }</span><span class="cov8" title="1"> else {
                //Send vote request to all other servers.
                respp := Send{PeerId: 0, Event: VoteReq{Term: sm.currTerm, CandId: sm.id, PreLoggInd: sm.LoggInd - 1, PreLoggTerm: sm.Logg.Logg[sm.LoggInd-1].Term}}
                sm.CommMedium.actionCh &lt;- respp
        }</span>
}

//Function for state to become leader.
func (sm *State_Machine) leadSys() <span class="cov8" title="1">{
        sm.status = LEAD    //Change state status to leader
        sm.votedFor = 0     //Reinitialize VoteFor
        sm.VoteGrant[0] = 0 //This is positive VoteGrant counter initialized to 1 i.e. self vote
        sm.VoteGrant[1] = 0 //This is negative VoteGrant counter initialized to 0
        sm.initialize()     //initialize MatchIndex and nextIndex
        sm.LeaderId = sm.id
        //fmt.Println("***&gt;&gt;&gt;", sm)
        resp := Alarm{T: LTO} //175
        //Set heartbeat timeout
        sm.CommMedium.actionCh &lt;- resp
        //Send heartbeat msg to all other servers
        //PeerId:0 means to all servers.
        if len(sm.Logg.Logg) == 0 </span><span class="cov8" title="1">{
                respp := Send{PeerId: 0, Event: AppEntrReq{Term: sm.currTerm, LeaderId: sm.id, PreLoggInd: 0, PreLoggTerm: 0, LeaderCom: 0}}
                sm.CommMedium.actionCh &lt;- respp
        }</span><span class="cov0" title="0"> else {
                respp := Send{PeerId: 0, Event: AppEntrReq{Term: sm.currTerm, LeaderId: sm.id, PreLoggInd: sm.LoggInd - 1, PreLoggTerm: sm.Logg.Logg[sm.LoggInd-1].Term, LeaderCom: sm.CommitIndex}}
                sm.CommMedium.actionCh &lt;- respp
        }</span>
}

//This will keep listening to all incomming channels and procceed the request as it arrives.
func (sm *State_Machine) EventProcess() <span class="cov8" title="1">{
        var msg Message
        for </span><span class="cov8" title="1">{
                //fmt.Println("In EventProcess")
                select </span>{

                //Timeout Event.
                <span class="cov8" title="1">case &lt;-sm.CommMedium.timeoutCh:
                        //Generate corrosponding response to the request.
                        switch sm.status </span>{
                        <span class="cov8" title="1">case FOLL:
                                sm.candSys()</span>

                        <span class="cov8" title="1">case CAND:
                                //Start election for next Term again.
                                sm.candSys()</span>

                        <span class="cov8" title="1">case LEAD:
                                //fmt.Println("Heartbeat-", len(sm.Logg.Logg))
                                //Commit the Logg and send heartbeat msg to all other servers.
                                sm.commitLogg()
                                if len(sm.Logg.Logg) == 0 </span><span class="cov0" title="0">{
                                        respp := Send{PeerId: 0, Event: AppEntrReq{Term: sm.currTerm, LeaderId: sm.id, PreLoggInd: 0, PreLoggTerm: 0, LeaderCom: 0}}
                                        //fmt.Println("---&gt;&gt;", sm.currTerm, " : ", time.Now())
                                        sm.CommMedium.actionCh &lt;- respp
                                        resp := Alarm{T: LTO} //175
                                        //Set heartbeat timeout
                                        sm.CommMedium.actionCh &lt;- resp
                                }</span><span class="cov8" title="1"> else {
                                        respp := Send{PeerId: 0, Event: AppEntrReq{Term: sm.currTerm, LeaderId: sm.id, PreLoggInd: sm.LoggInd - 1, PreLoggTerm: sm.Logg.Logg[sm.LoggInd-1].Term, LeaderCom: sm.CommitIndex}}
                                        sm.CommMedium.actionCh &lt;- respp
                                        resp := Alarm{T: LTO} //175
                                        //Set heartbeat timeout
                                        sm.CommMedium.actionCh &lt;- resp
                                }</span>
                        }

                //Requests from client machine.
                <span class="cov8" title="1">case appendMsg := &lt;-sm.CommMedium.clientCh:
                        msg = appendMsg.(Append)
                        msg.commit(sm)</span>

                //Request from PEERS in the cluster.
                <span class="cov8" title="1">case PeerMsg := &lt;-sm.CommMedium.netCh:
                        //Generate corrosponding response to the request.
                        switch PeerMsg.(type) </span>{
                        <span class="cov8" title="1">case AppEntrReq:
                                msg = PeerMsg.(AppEntrReq)
                                msg.send(sm)</span>
                        <span class="cov8" title="1">case AppEntrResp:
                                msg = PeerMsg.(AppEntrResp)
                                msg.send(sm)</span>
                        <span class="cov8" title="1">case VoteReq:
                                msg = PeerMsg.(VoteReq)
                                msg.send(sm)</span>
                        <span class="cov8" title="1">case VoteResp:
                                //fmt.Println("&lt;&lt;&lt;IN&lt;&lt;&lt;")
                                msg = PeerMsg.(VoteResp)
                                msg.send(sm)</span>
                        }

                }
        }
}

//Process incommimg append entry request.
//Incoming Logg or any incoming variable means the Logg or variable form the given incomming request or respoonse msg.
func (appReq AppEntrReq) send(sm *State_Machine) <span class="cov8" title="1">{
        //fmt.Println("---&gt;", sm.id, appReq, len(appReq.Logg.Logg))

        switch sm.status </span>{
        //For every incoming signal from leader to follower reset the timeout time as leader is still alive.
        <span class="cov8" title="1">case FOLL:
                //fmt.Println("---&gt;&gt;&gt;&gt;", appReq)

                if len(appReq.Logg.Logg) == 0 </span><span class="cov8" title="1">{
                        //Reset the timeout timer.
                        sm.currTerm = appReq.Term
                        respp := Alarm{T: FTO}
                        sm.CommMedium.actionCh &lt;- respp
                        sm.commitLogg()
                        return
                }</span>

                //Send regative reply, if incoming Term is lower than local Term or previous Index does not match.
                //fmt.Println(((appReq.PreLoggInd &gt; sm.LoggInd-1) &amp;&amp; len(sm.Logg.Logg) != 0))
                <span class="cov8" title="1">if (sm.currTerm &gt; appReq.Term) || ((appReq.PreLoggInd &gt; sm.LoggInd-1) &amp;&amp; len(sm.Logg.Logg) != 0) </span><span class="cov8" title="1">{
                        //        fmt.Println("&gt;&gt;&gt; 2 :", sm.id, "=", appReq.Term)
                        //        fmt.Println(appReq.PreLoggInd, " ~~ ", sm.LoggInd-1)

                        resp := Send{PeerId: appReq.LeaderId, Event: AppEntrResp{Term: sm.currTerm, Succ: false}}
                        sm.CommMedium.actionCh &lt;- resp
                        respp := Alarm{T: FTO}
                        sm.CommMedium.actionCh &lt;- respp
                        return
                }</span>

                //Send regative reply, if previous entry does not match.   , (!reflect.DeepEqual(sm.Logg.Logg[appReq.PreLoggInd], appReq.Logg.Logg[0]))
                <span class="cov8" title="1">if ((appReq.PreLoggInd != sm.LoggInd-1) &amp;&amp; (len(sm.Logg.Logg) != 0)) &amp;&amp; (appReq.PreLoggTerm == sm.currTerm) || ((len(sm.Logg.Logg) != 0) &amp;&amp; (!reflect.DeepEqual(sm.Logg.Logg[appReq.PreLoggInd], appReq.Logg.Logg[0]))) </span><span class="cov0" title="0">{
                        //        fmt.Println("&gt;&gt;&gt; 3:", sm.id)

                        resp := Send{PeerId: appReq.LeaderId, Event: AppEntrResp{Term: sm.currTerm, Succ: false}}
                        sm.CommMedium.actionCh &lt;- resp
                        respp := Alarm{T: FTO}
                        sm.CommMedium.actionCh &lt;- respp
                        return
                }</span>

                //Update local CommitIndex with minimum of incomming LeaderCommit and local Logg Index
                <span class="cov8" title="1">sm.CommitIndex = int32(math.Min(float64(appReq.LeaderCom), float64(sm.LoggInd-1)))
                //Update local Term to incomming Term.
                sm.currTerm = appReq.Term
                prevInd := sm.LoggInd //index on which data will store.
                //Copy incoming Logg into local Logg.
                sm.LoggInd, sm.Logg = copyLogg(sm.currTerm, sm.LoggInd, appReq.PreLoggInd, sm.Logg, appReq.Logg)
                //Send possitive reply, as Logg has been copied to local Logg.
                resp := Send{PeerId: appReq.LeaderId, Event: AppEntrResp{Term: sm.currTerm, Succ: true}}
                sm.CommMedium.actionCh &lt;- resp
                //Reset the timeout timer.
                respp := Alarm{T: FTO}
                sm.CommMedium.actionCh &lt;- respp
                sm.commitLogg()
                sm.actionCh &lt;- LoggStore{Data: (sm.Logg.Logg[prevInd:])}
                sm.CommMedium.CommitCh &lt;- CommitInfo{Data: []byte(appReq.Logg.Logg[1].Logg), Err: nil, Index: sm.LoggInd - 1}</span>

        <span class="cov0" title="0">case CAND:
                //Become follower and amd process incomming append entry request, if incomming Term higher than or eqaul(already have Term) to local Term.
                if appReq.Term &gt;= sm.currTerm </span><span class="cov0" title="0">{
                        sm.status = FOLL
                        sm.votedFor = 0
                        sm.currTerm = appReq.Term
                        appReq.send(sm)
                        return
                }</span>
                //Reply negative if incomming Term is lower.
                <span class="cov0" title="0">resp := Send{PeerId: appReq.LeaderId, Event: AppEntrResp{Term: sm.currTerm, Succ: false}}
                sm.CommMedium.actionCh &lt;- resp</span>

        <span class="cov0" title="0">case LEAD:
                //Become a follower, if incomming Term higher than local Term.
                if appReq.Term &gt; sm.currTerm </span><span class="cov0" title="0">{
                        if appReq.PreLoggInd &gt; sm.LoggInd-1 </span><span class="cov0" title="0">{
                                resp := Send{PeerId: appReq.LeaderId, Event: AppEntrResp{Term: sm.currTerm, Succ: false}}
                                sm.CommMedium.actionCh &lt;- resp
                                sm.currTerm = appReq.Term
                                sm.FollSys()
                        }</span>
                        <span class="cov0" title="0">resp := Send{PeerId: appReq.LeaderId, Event: AppEntrResp{Term: sm.currTerm, Succ: false}}
                        sm.CommMedium.actionCh &lt;- resp
                        return</span>
                }
                //Reply negative if incomming Term is lower.
                <span class="cov0" title="0">resp := Send{PeerId: appReq.LeaderId, Event: AppEntrResp{Term: sm.currTerm, Succ: false}}
                sm.CommMedium.actionCh &lt;- resp</span>
        }
        <span class="cov8" title="1">return</span>
}

//Process incommimg append entry response.
func (appRes AppEntrResp) send(sm *State_Machine) <span class="cov8" title="1">{
        switch sm.status </span>{
        <span class="cov8" title="1">case LEAD:
                //On positive response, update MatchIndex and NextIndex.
                if appRes.Succ == true </span><span class="cov8" title="1">{
                        sm.MatchIndex[appRes.Peer-1] = sm.LoggInd - 1
                        sm.NextIndex[appRes.Peer-1] = sm.LoggInd
                }</span>
                //On negative response, decreament the NextIndex with respect to incomming Peer and resend append entry request.
                <span class="cov8" title="1">if appRes.Succ == false </span><span class="cov8" title="1">{
                        if appRes.Term &gt; sm.currTerm </span><span class="cov0" title="0">{
                                sm.currTerm = appRes.Term
                                sm.FollSys()
                        }</span>
                        <span class="cov8" title="1">temp := sm.NextIndex[appRes.Peer-1] - 1
                        if temp &lt; 0 </span><span class="cov0" title="0">{
                                temp = 0
                        }</span>
                        <span class="cov8" title="1">sm.NextIndex[appRes.Peer-1] -= 1
                        //temp := sm.NextIndex[appRes.Peer-1] - 1
                        entry := sm.Logg.Logg[temp:]
                        entry1 := Logg{Logg: entry}
                        //Check for Logg to be commited.
                        resp := Send{PeerId: appRes.Peer, Event: AppEntrReq{Term: sm.currTerm, LeaderId: sm.id, PreLoggInd: temp, PreLoggTerm: sm.Logg.Logg[temp].Term, LeaderCom: sm.CommitIndex, Logg: entry1}}
                        sm.CommMedium.actionCh &lt;- resp</span>
                }
                <span class="cov8" title="1">sm.commitLogg()</span>
        }
}

//Process incommimg vote request.
func (votReq VoteReq) send(sm *State_Machine) <span class="cov8" title="1">{
        switch sm.status </span>{
        <span class="cov8" title="1">case FOLL:
                //If CandIdate Logg is not uptodate or incoming Term is lower or already voted in given Term, then reply negative.
                if votReq.Term &lt; sm.currTerm || sm.votedFor != 0 || votReq.PreLoggInd &lt;= sm.LoggInd-1 </span><span class="cov8" title="1">{
                        resp := Send{PeerId: votReq.CandId, Event: VoteResp{Term: sm.currTerm, VoteGrant: false}}
                        sm.CommMedium.actionCh &lt;- resp
                        return
                }</span>
                //Vote to incomming CandIdate and set the votedFor to 1.
                <span class="cov8" title="1">sm.votedFor = 1
                sm.currTerm = votReq.Term
                resp := Send{PeerId: votReq.CandId, Event: VoteResp{Term: sm.currTerm, VoteGrant: true}}
                sm.CommMedium.actionCh &lt;- resp
                respp := Alarm{T: FTO}
                sm.CommMedium.actionCh &lt;- respp</span>

        <span class="cov0" title="0">case CAND:
                if sm.currTerm &lt; votReq.Term </span><span class="cov0" title="0">{
                        resp := Send{PeerId: votReq.CandId, Event: VoteResp{Term: sm.currTerm, VoteGrant: true}}
                        sm.CommMedium.actionCh &lt;- resp
                        sm.currTerm = votReq.Term
                        sm.FollSys()
                        return
                }</span>
                //Reject the incomming vote Request.
                <span class="cov0" title="0">resp := Send{PeerId: votReq.CandId, Event: VoteResp{Term: sm.currTerm, VoteGrant: false}}
                sm.CommMedium.actionCh &lt;- resp</span>

        <span class="cov8" title="1">case LEAD:
                //Reply negative  in any case for vote request.
                if sm.currTerm &gt; votReq.Term </span><span class="cov0" title="0">{
                        resp := Send{PeerId: votReq.CandId, Event: VoteResp{Term: sm.currTerm, VoteGrant: false}}
                        sm.CommMedium.actionCh &lt;- resp
                }</span>
                //But if incomming Term is higher than local, then step down to follower state.
                <span class="cov8" title="1">if sm.currTerm &lt; votReq.Term </span><span class="cov8" title="1">{
                        if votReq.PreLoggInd &gt; sm.LoggInd-1 </span><span class="cov0" title="0">{
                                resp := Send{PeerId: votReq.CandId, Event: VoteResp{Term: sm.currTerm, VoteGrant: false}}
                                sm.CommMedium.actionCh &lt;- resp
                                sm.currTerm = votReq.Term
                                sm.FollSys()
                        }</span>
                        <span class="cov8" title="1">resp := Send{PeerId: votReq.CandId, Event: VoteResp{Term: sm.currTerm, VoteGrant: false}}
                        sm.CommMedium.actionCh &lt;- resp</span>
                }
        }
}

//Process incommimg vote response.
func (votRes VoteResp) send(sm *State_Machine) <span class="cov8" title="1">{
        switch sm.status </span>{
        <span class="cov8" title="1">case CAND:
                //Count incomming positive responses.
                if votRes.VoteGrant == true </span><span class="cov8" title="1">{
                        sm.VoteGrant[0] += 1
                }</span>
                //Count incomming negative responses.
                <span class="cov8" title="1">if votRes.VoteGrant == false </span><span class="cov8" title="1">{
                        sm.VoteGrant[1] += 1
                        if votRes.Term &gt; sm.currTerm </span><span class="cov0" title="0">{
                                sm.FollSys()
                                return
                        }</span>
                }
                //Become Leader if positive responses are atleat 3.
                <span class="cov8" title="1">if sm.VoteGrant[0] &gt;= MAX </span><span class="cov8" title="1">{
                        sm.leadSys()
                        return
                }</span>
                //Step down to Follower if negative responses are atleat 3.
                <span class="cov8" title="1">if sm.VoteGrant[1] &gt;= MAX </span><span class="cov8" title="1">{
                        sm.FollSys()
                        return
                }</span>
                //Do reelection due to cluster partioning.
                <span class="cov8" title="1">if sm.VoteGrant[0] == 2 &amp;&amp; sm.VoteGrant[1] == 2 </span><span class="cov0" title="0">{
                        sm.candSys()
                        return
                }</span>
        }
}

//Process incommimg append request.
func (app Append) commit(sm *State_Machine) <span class="cov8" title="1">{
        switch sm.status </span>{
        <span class="cov0" title="0">case FOLL:
                //Send Error.
                resp := Commit{Data: []byte("5000"), Err: []byte("I'm not leader")}
                sm.CommMedium.actionCh &lt;- resp</span>

        <span class="cov0" title="0">case CAND:
                //Send Error.
                resp := Commit{Data: []byte("5000"), Err: []byte("I'm not leader")}
                sm.CommMedium.actionCh &lt;- resp</span>

        <span class="cov8" title="1">case LEAD:
                //Append the commond into local Logg.
                var temp int
                entry := Logg{Logg: []MyLogg{{-1, " "}, {sm.currTerm, string(app.Data)}}}
                sm.LoggInd, sm.Logg = copyLogg(sm.currTerm, sm.LoggInd, sm.LoggInd-1, sm.Logg, entry)
                entry11 := sm.Logg.Logg
                if len(sm.Logg.Logg) == 1 </span><span class="cov8" title="1">{
                        entry11 = []MyLogg{{-1, "nil"}, {sm.currTerm, string(app.Data)}}
                }</span><span class="cov8" title="1"> else {
                        temp = len(sm.Logg.Logg) - 2
                        entry11 = sm.Logg.Logg[temp:]
                }</span>
                <span class="cov8" title="1">entry1 := Logg{Logg: entry11}
                entry111 := sm.Logg.Logg[temp:]
                resp := LoggStore{Data: entry111}
                //Send the append entry request to all other servers.
                respp := Send{PeerId: 0, Event: AppEntrReq{Term: sm.currTerm, LeaderId: sm.id, PreLoggInd: sm.LoggInd - 1, PreLoggTerm: sm.Logg.Logg[sm.LoggInd-1].Term, LeaderCom: sm.CommitIndex, Logg: entry1}}

                sm.CommMedium.actionCh &lt;- resp
                sm.CommMedium.actionCh &lt;- respp
                sm.CommMedium.CommitCh &lt;- CommitInfo{Data: []byte(sm.Logg.Logg[sm.LoggInd-1].Logg), Err: nil, Index: sm.LoggInd - 1}</span>

        }
}

//Commit the Logg, function initiated by leader.
func (sm *State_Machine) commitLogg() <span class="cov8" title="1">{
        for i := sm.CommitIndex + 1; i &lt; sm.LoggInd; i++ </span><span class="cov8" title="1">{
                if sm.Logg.Logg[i].Term != sm.currTerm </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">count := 0
                for j := 0; j &lt; PEERS; j++ </span><span class="cov8" title="1">{
                        if sm.MatchIndex[j] &gt;= i </span><span class="cov8" title="1">{
                                count += 1
                        }</span>
                }
                <span class="cov8" title="1">if count &gt;= MAX </span><span class="cov8" title="1">{
                        sm.CommitIndex = i
                        break</span>
                }
        }
}

//Used to copy Logg from given request to state machine.
func copyLogg(Term int32, myInd int32, preInd int32, oldLogg Logg, newLogg Logg) (int32, Logg) <span class="cov8" title="1">{
        for i := 1; i &lt; len(newLogg.Logg); i++ </span><span class="cov8" title="1">{
                temp := preInd + int32(i)
                if len(oldLogg.Logg) != 0 </span><span class="cov8" title="1">{
                        oldLogg.Logg = append(oldLogg.Logg[:temp], newLogg.Logg[i])
                }</span><span class="cov8" title="1"> else {
                        oldLogg.Logg = append(oldLogg.Logg, newLogg.Logg[i])
                }</span>
                <span class="cov8" title="1">myInd++</span>
        }
        <span class="cov8" title="1">return myInd, oldLogg</span>
}

//Initializing the MatchIndex and NextIndex.
func (sm *State_Machine) initialize() <span class="cov8" title="1">{
        for i := 0; i &lt; PEERS; i++ </span><span class="cov8" title="1">{
                sm.MatchIndex[i] = 0
                sm.NextIndex[i] = sm.LoggInd
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
